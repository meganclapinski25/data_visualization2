<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Stacked Bar Chart — Coffee by Time of Day</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    svg { max-width: 100%; height: auto; }
    .chart-title { font-weight: 700; margin-bottom: 8px; }
    
  </style>
</head>
<body>

  <div class="chart-title">Coffee Orders by Time of Day (Stacked by Coffee Type)</div>
  <svg id="chart" width="800" height="480" viewBox="0 0 800 480"></svg>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
  const svg = d3.select("#chart");
  const width = 800, height = 480;
  const margin = { top: 32, right: 180, bottom: 56, left: 64 };

  // Change path if needed:
  d3.csv("Coffe_sales.csv", d3.autoType).then(raw => {
    // Normalize/trim fields in case of minor CSV inconsistencies
    const data = raw.map(d => ({
      Time_of_Day: String(d.Time_of_Day).trim(),
      coffee: (d.coffeetype ?? d.coffee_name ?? "").toString().trim()
    })).filter(d => d.Time_of_Day && d.coffee);

    // Stack keys = distinct coffee types (in first-seen order)
    const types = d3.union(data.map(d => d.coffee));

    // Count rows per (Time_of_Day, coffee) → Map<Time_of_Day, Map<coffee, count>>
    const counts = d3.rollup(
      data,
      v => v.length,
      d => d.Time_of_Day,
      d => d.coffee
    );

    // Build "wide" rows directly from the counts Map (NO hardcoded time buckets)
    // rows: [{ Time_of_Day, Latte: n, Espresso: n, ... }, ...]
    const rows = Array.from(counts, ([Time_of_Day, byType]) => {
      const o = { Time_of_Day };
      types.forEach(t => o[t] = byType.get(t) ?? 0); // zero-fill missing combos
      return o;
    });

    // If nothing to plot, bail early
   

    // Create stack series
    const series = d3.stack().keys(types)(rows);

    // Scales
    const x = d3.scaleBand()
      .domain(rows.map(d => d.Time_of_Day))
      .range([margin.left, width - margin.right])
      .padding(0.1);

    const y = d3.scaleLinear()
      .domain([0, d3.max(series, s => d3.max(s, d => d[1]))]).nice()
      .range([height - margin.bottom, margin.top]);

    const color = d3.scaleOrdinal()
      .domain(types)
      .range(d3.schemeTableau10);

    // Draw stacks
    const gLayers = svg.append("g");
    gLayers.selectAll("g.layer")
      .data(series)
      .join("g")
        .attr("class", "layer")
        .attr("fill", d => color(d.key))
      .selectAll("rect")
      .data(S => S.map(d => (d.key = S.key, d))) // attach key (coffee type) to each rect
      .join("rect")
        .attr("x", d => x(d.data.Time_of_Day))
        .attr("y", d => y(d[1]))
        .attr("height", d => y(d[0]) - y(d[1]))
        .attr("width", x.bandwidth())
      .append("title")
        .text(d => `${d.data.Time_of_Day} — ${d.key}: ${d.data[d.key]}`);

    // Axes
    svg.append("g")
      .attr("transform", `translate(0,${height - margin.bottom})`)
      .call(d3.axisBottom(x))
      .call(g => g.selectAll(".domain").remove());

    svg.append("g")
      .attr("transform", `translate(${margin.left},0)`)
      .call(d3.axisLeft(y).ticks(null, "s"))
      .call(g => g.selectAll(".domain").remove())
      .call(g => g.append("text")
        .attr("x", 0)
        .attr("y", margin.top - 12)
        .attr("fill", "currentColor")
        .attr("font-weight", "600")
        .attr("text-anchor", "start")
        .text("Total orders"));

    // Legend
    const legend = svg.append("g")
      .attr("class", "legend")
      .attr("transform", `translate(${width - margin.right + 20}, ${margin.top})`)
      .attr("font-size", 12);

    const legendItem = legend.selectAll("g.item")
      .data(types)
      .join("g")
        .attr("class", "item")
        .attr("transform", (d, i) => `translate(0, ${i * 20})`);

    legendItem.append("rect")
      .attr("width", 14)
      .attr("height", 14)
      .attr("fill", d => color(d));

    legendItem.append("text")
      .attr("x", 20)
      .attr("y", 7)
      .text(d => d);

    // helpful debug in console
    console.log("types:", types);
    console.log("counts (Map of Maps):", counts);
    console.log("rows (wide format):", rows);
    console.log("series (stack output):", series);
  });
  </script>
</body>
</html>
